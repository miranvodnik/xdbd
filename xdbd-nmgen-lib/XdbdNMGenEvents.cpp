/*
 * XdbdNMGenEvents.cpp
 *
 *  Created on: 11. feb. 2016
 *      Author: miran
 */

#include "XdbdNMGenEvents.h"

namespace xml_db_daemon
{

/*! @brief constructor of 'events' descriptor
 *
 *  it initializes references to all three possible
 *  trigger events: delete, insert and update
 *
 */
XdbdNMGenEvents::XdbdNMGenEvents ()
{
	m_delete = 0;
	m_insert = 0;
	m_update = 0;
}

/*! @brief destructor of 'events' descriptor
 *
 *  it deletes all trigger event descriptors
 *
 */
XdbdNMGenEvents::~XdbdNMGenEvents ()
{
	delete m_delete;
	delete m_insert;
	delete m_update;
}

/*! @brief read sub-nodes of 'events'
 *
 *  reads all sub-nodes but recognizes only those named 'delete',
 *  'insert' or 'update' but it remembers only one (last) instance
 *  for each of them. Other descriptors are simply ignored
 *
 *  @param node reference to XML 'events' node
 *
 */
int XdbdNMGenEvents::ReadSubNodes (xmlNodePtr node)
{
	for (xmlNodePtr child = node->children; child != 0; child = child->next)
	{
		string name = (char*) child->name;
		if (name == g_delete)
		{
			delete m_delete;
			m_delete = new XdbdNMGenEventsDelete ();
			m_delete->ReadSubNodes (child);
		}
		else if (name == g_insert)
		{
			delete m_insert;
			m_insert = new XdbdNMGenEventsInsert ();
			m_insert->ReadSubNodes (child);
		}
		else if (name == g_update)
		{
			delete m_update;
			m_update = new XdbdNMGenEventsUpdate ();
			m_update->ReadSubNodes (child);
		}
		else
		{

		}
	}
	return 0;
}

/*! @brief read attributes
 *
 *  since 'events' node has no attributes, this function does
 *  nothing.
 *
 *  @param node reference to XML 'events' node
 *
 */
int XdbdNMGenEvents::ReadAttributes (xmlNodePtr node)
{
	return 0;
}

/*! @brief generate code
 *
 *  function generates two code fragments depending on the value
 *  of parameter data[0] holding value for GenerateFlags. All code
 *  is generated by sub-nodes except when data[0] equals GenerateImplementation.
 *  In this case switch statement is generated with case value
 *  Data_Op_Type which reflects trigger being fired and curly braces surrounding
 *  switch statement. Actual case statements are generated by 'delete', 'insert'
 *  and 'update' descriptors.
 *
 *  @param dataCount size of data[] table - should be 2
 *  @param data code generation parameters - code generation flag
 *  and reference to output file object
 *
 *  @return 0 always
 *
 */
int XdbdNMGenEvents::GenerateCode (int dataCount, void* data [])
{
	ofstream* outFile = (ofstream*) data [1];

	switch ((GenerateFlags) (long) data [0])
	{
	case GenerateMQDefinitions:
	case GenerateMQInitializations:
		if (m_insert != 0)
			m_insert->GenerateCode (dataCount, data);
		if (m_update != 0)
			m_update->GenerateCode (dataCount, data);
		if (m_delete != 0)
			m_delete->GenerateCode (dataCount, data);
		break;
	case GenerateImplementation:
		*outFile << "   switch (Data_Op_Type)" << endl;
		*outFile << "   {" << endl;
		if (m_insert != 0)
			m_insert->GenerateCode (dataCount, data);
		if (m_update != 0)
			m_update->GenerateCode (dataCount, data);
		if (m_delete != 0)
			m_delete->GenerateCode (dataCount, data);
		*outFile << "      default:" << endl;
		*outFile << "         break;" << endl;
		*outFile << "   }" << endl;
		break;
	default:
		break;
	}
	return 0;
}

/*! @brief check column usage
 *
 *  recursively check usage of specific DB column in generated
 *  code
 *
 *  @param name name of DB column
 *
 *  @return true column name found in generated code
 *  @return false column name not found in generated code
 *
 */
bool XdbdNMGenEvents::CheckColumnUsage (const char* name)
{
	return	((m_insert != 0) && m_insert->CheckColumnUsage(name)) ||
		((m_update != 0) && m_update->CheckColumnUsage(name)) ||
		((m_delete != 0) && m_delete->CheckColumnUsage(name));
}

} /* namespace xml_db_daemon */
